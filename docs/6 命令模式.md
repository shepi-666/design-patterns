> [查看源码](https://github.com/shepi-666/design-patterns)

# 命令模式

将**方法调用(method invocation)**封装起来。调用此运算的对象不需要关注事情是如何进行的，只要知道如何使用包装成形的方法来完成他们就可以。

## 对象餐厅的工作模式

* 顾客根据需要创建订单：`createOrder()`
* 订单包括一个订单表格，顾客订购的东西写在上面
* 女招待拿走订单(`takeOrder()`)，然后放在订单柜台，调用`orderUp()`方法，通知厨师
* 订单上有所有准备餐点的指示，指导厨师烹饪
* 快餐厨师根据指令准备餐点
* 出餐

## 角色和职责

### 一张订单封装了准备餐点的请求

订单接口只包含一个方法`orderUp()`，用来指导厨师烹饪，同时订单有一个厨师的引用。

### 女招待

女招待只需要接受不同的单子`takeOrder(Order order)`，然后调用单子的`orderUp()`方法告知厨师烹饪即可

### 快餐师傅

女招待调用`orderUp()`方法之后，快餐厨师就接手，实现创建餐点的所有方法。女招待和师傅是彻底的解耦关系。

## 命令模式

![](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/command.png)

> 3 客户要求调用者执行命令。一旦命令被加载到调用者上，该命令可以使用之后被丢弃或者被保留下来使用多次。

## 第一个命令对象

见`src`

## 定义命令模式

> **命令模式**将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也可以支持撤销的操作。

* 命令对象通过在特定的接受者上绑定一组动作来封装一个请求。
* `execute()`方法用来封装动作以及接收者

### 类图

![image-20220831221652772](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/image-20220831221652772.png)

## 实现遥控器

![](https://shepi-1308499968.cos.ap-chengdu.myqcloud.com/img/遥控器模型.png)

源码见`src`

## 命令模式——队列请求

命令可以将运算快打包（一个接收者和一组动作），然后将它传来传去。他甚至可以在不同的线程中被调用。我们可以利用这样的性质来衍生一些应用：日程安排、线程池、工作队列等。

假设有一个工作队列，某一端添加命令，另一端则是一个线程。线程进行下面的动作：从队列中取出一个命令，调用他的`execute()`方法，等待调用完成之后就将这个命令对象丢弃，取出下一个命令。

## 命令模式——日志请求

某些应用需要我们将所有的动作都记录在日志中，并能够在系统死机的时候，重新调用这些动作恢复到之前的状态。通过新增`store()`和`load()`方法，命令模式可以实现这一点。

## 总结

* 命令模式将发出请求的对象和执行请求的对象解耦
* 被解耦的两个对象是通过命令对象进行沟通的，命令对象封装了接收者一个或者一组动作
* 调用者通过调用`execute()`方法发出请求，接收者的动作被调用
* 命令可以支持撤销，实现`undo()`方法来实现命令被执行前的动作
* 宏命令是命令的一种简单的延伸，允许调用多个命令，也支持撤销
* 命令模式可以用来实现日志和事务系统